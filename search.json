[{"title":"2017年个人年度总结","url":"http://yoursite.com/2017/12/31/2017年个人年度总结/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>又是一年过去,当我动笔写这个总结的时候,2017年已经过去了1分钟,父母老婆孩子都早已入睡.然而,一个人活着,总要留下一点活着的证据.</p>\n<p>借此机会,终于可以更新一下久未更新的博客.</p>\n<p>毕竟,2017年对我来说又是一个完成人生节点最多的一年.</p>\n<h1 id=\"时间戳\"><a href=\"#时间戳\" class=\"headerlink\" title=\"时间戳\"></a>时间戳</h1><h2 id=\"2017-01-08\"><a href=\"#2017-01-08\" class=\"headerlink\" title=\"#2017.01.08\"></a>#2017.01.08</h2><p>回想起来当时大约是1月7号晚上8点多吧,当时老爸老妈都在忙他们的事业,跟老婆在烛光晚餐的时候突然她说肚子好痛,接下来的一段时间内也是一阵一阵的痛,预产期也是这一天,然后我们都觉得,新的生命即将要到来了(当然,当时的两个人,一个只有紧张,一个只有痛).<br>于是,晚上9点多的时候把老婆送到了新妇幼, 挂完号让医生一检查,已经是2指了,可以进入待产室,紧张感油然而生,同时也佩服老婆的深谋远虑,在前几天已经把待产的东西放到车库了.<br>手续办完,检查完,躺在待产室床上的时候已经是11点多了.看到老婆在床上这么辛苦,也只能干坐着,然后把肩膀给她掐一下,感觉很没心没肺的样子(实则内心波涛汹涌).直到现在每次被骂,都是说我没心没肺 XD<br>8号凌晨1点44分,医生说可以进产房了,然后又把认识的妇产科医生从家里请了过来帮忙接生.<br>然后,在产房外面焦急的等待着(tvb电视剧既视感),妈妈也在一边通知人.<br>8号凌晨2点29分,医生推了一个婴儿车,男,五斤六,我自名其为Karson. 随即喜大普奔,奔走相告,发了好多微信红包.<br>把Karson安顿去了产妇房后, 把妇产科医生载了回去休息后,又继续回来在产房等老婆出来.<br>8号凌晨4点多的时候, 终于看到她出来了,母子平安,大善.此处我做的最不好的就是那时我们准备的红牛,士力架,巧克力在推进产房的时候竟然没有一并带进去,当意识到这个事的时候,老婆已经生完了.</p>\n<p>附上一张Karson刚出来时候的照片:<br><img src=\"/images/image/Karson.jpeg\" width=\"250px\"></p>\n<p>现在已经长成一个小帅窝了(颇有其爹风范):<br><img src=\"/images/image/now.JPG\" width=\"250px\"></p>\n<p>对我来说，即是责任，又是一个学习为人父的过程吧。</p>\n<h2 id=\"2017-07-17\"><a href=\"#2017-07-17\" class=\"headerlink\" title=\"#2017.07.17\"></a>#2017.07.17</h2><p>2017年7月14日，从东方海外货柜航运有限公司离职，离开了我从实习开始一直工作的老东家。里面有着一直很关照我的部门老大们，有着一群从入职ITA培训到离开都相处的很愉快的小伙伴，有着影响了我个人工作理念的作风，有着最先进的技术和企业管理理念。</p>\n<p>离开的老同事都说这里是珠海IT的黄埔军校，我也深有同感。</p>\n<p>“We take it personally.”, 以人为本，这个老东家的Slogan, 包含了太多太多可思考的东西。</p>\n<p>当然，硬币的另一面，是缺乏狼性，缺少KPI考核，呆久了容易安于现状。</p>\n<p>(but, 此生若能安稳，谁愿颠沛流离？)</p>\n<p>然而最终因为个人原因，不得不离开这个“桃花源”，回到离家更近的地方。</p>\n<p>2017年7月17日，正式入职碧桂园物业服务有限公司，成为信息管理中心应用与数据开发部的一员。</p>\n<p>在这里，接触了新的团队，带头的是一个管理作风彪悍，技术性强的leader。</p>\n<p>简单总结了7月份到12月就是“忙时累成狗，闲时啥都干，月月都愁KPI，早日成全栈”（单押x4）</p>\n<p>当然，因为部门刚成立，一切都还在磨合练兵，一切还看2018（小激动一波）</p>\n<h2 id=\"2017-10-01\"><a href=\"#2017-10-01\" class=\"headerlink\" title=\"#2017.10.01\"></a>#2017.10.01</h2><p>小伙伴老说我的人生进程有点快，25岁已经结婚生子人生赢家了。我觉得还好，修身，齐家，治国，平天下。既然有不能辜负的人，何不早日给她一个归宿？尽管作为一个老公、\b父亲，至今为止做的并不是很好。</p>\n<p>2017年10月1日，与我老婆终于完成了传统的婚礼仪式。其实在2015年10月27日已经领证，但是因为白事的原因，硬生生拖到了今年才摆酒，拖到儿子都出生了（手动捂脸）</p>\n<p>po个婚纱照：<br><img src=\"/images/image/marry.JPG\" alt=\"marry\"></p>\n<p>再次感谢当前家人亲戚和兄弟以及远道而来的朋友们的到来和帮助。</p>\n<h1 id=\"工作与学习\"><a href=\"#工作与学习\" class=\"headerlink\" title=\"工作与学习\"></a>工作与学习</h1><p>我是14年11月份出来实习的，到最近已经三年有多了。</p>\n<p><img src=\"/images/image/card.jpeg\" width=\"300px\"><br><img src=\"/images/image/card1.JPG\" width=\"300px\"></p>\n<p>这些卡片完美的代表了我几个阶段，实习，培训，工作，新工作。</p>\n<p>实习时学习的更多了移动端及混合应用的基础知识。</p>\n<p>培训时让我了解了整个项目结构从后台到前台的运行模式。</p>\n<p>工作时让我从项目中提升了我的硬技能和软技能。</p>\n<p>新工作让我知道了狼性管理风格和产品的思考和迭代过程。</p>\n<p>2017年，对于持续学习这一块，我是及格的，继续发扬。对于工作，在老东家有个遗憾，就是移动端的组件化想法最后因为我的离开不知道怎样了。在新地方，因为团队初创的原因，错失了好多锻炼的机会，然而在前端开发和DevOps还是有了点进步吧，此处给自己59分，引以为戒。对于业务，20分，下一年要狠抓。对于个人，在专业方向对人姿态太低，对自己要求太低，这是不自信的表现，下一年要狠狠的改正。</p>\n<p>在此立个flag，下一年来回顾。</p>\n<h1 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h1><p>2017年，经历了太多太多，\b逐渐的在成为一个有经历的人。对于2018年，于工作，希望能做出一个好的产品，带动好团队的氛围，于家庭，希望能更好的关心家人，处理好家庭的关系。于自己，希望能更加自信。</p>\n<p>好吧，加油。</p>\n","categories":["summary"],"tags":["summary"]},{"title":"说说自己为什么建一个博客","url":"http://yoursite.com/2017/03/22/说说自己为什么建一个博客/","content":"<p>说出来你可能不信, 除了想试试Github Page建立博客的水之外, 我自己弄一个博客最大的原因是不想别人能在百度可以搜索到我写的东西. 假如你不幸看到这篇文章, 那么你应该是一个爬虫能手或者是我的朋友, 在这里恭喜你, 你偷窥到了我的小秘密.</p>\n<p>言归正传, 在这个博客里面我更多的是想达到以下几个目的:</p>\n<ol>\n<li>总结一下自己学习到的技术</li>\n<li>生活里面想吐槽的杂事</li>\n<li>当爸后的感想</li>\n<li>锻炼下自己的写作能力(学生生涯自以为不错的技能)</li>\n</ol>\n<p>个人觉得如果这个博客能实现如上所说的话, 那么我就花点钱买个域名和图床吧.</p>\n","categories":["心情随笔"],"tags":["随笔"]},{"title":"在判断软件是否第一次登录时如何让BOOL看上去更有可读性","url":"http://yoursite.com/2017/03/17/在判断软件是否第一次登录时如何让BOOL看上去更有可读性/","content":"<p>今天在为一个app做软件引导页需要判断用户是否进入app时遇到的一些关于BOOL的问题，在这里发表一下我的见解：</p>\n<h2 id=\"如何判断app是否第一次登录（大概思路）\"><a href=\"#如何判断app是否第一次登录（大概思路）\" class=\"headerlink\" title=\"如何判断app是否第一次登录（大概思路）\"></a>如何判断app是否第一次登录（大概思路）</h2><p>判断用户是否第一次登录app，通常的做法是用一个BOOL来记录用户“登录“的这一个行为，所以话在AppDelegate中会设定一个BOOL值（此处叫isFirstLaunch),让isFirstLaunch一开始为YES，当用户进入app并展示完引导页后，isFirstLaunch设置为NO，并把isFirstLaunch存储到UserDefault中。当用户下次进入app时，isFirstLaunch为NO，那么就不会加载引导页。从而通过这个BOOL来判断是否第一次登录。因为这个BOOL，所以问题来了。</p>\n<h2 id=\"BOOL那点事\"><a href=\"#BOOL那点事\" class=\"headerlink\" title=\"BOOL那点事\"></a>BOOL那点事</h2><p>此处先要普及一下，Objective-C的BOOL值默认为NO，这里就有点耐人寻味了，整篇文章其实就是因为这个原因而展开的。<br>在网上查阅了挺多关于iOS如何判断app第一次启动的代码，此处举例一个（作者就不列了）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(![[NSUserDefaults standardUserDefaults] boolForKey:@&quot;firstStart&quot;])&#123;</div><div class=\"line\">        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@&quot;firstStart&quot;];</div><div class=\"line\">        NSLog(@&quot;第一次启动&quot;);</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        NSLog(@&quot;不是第一次启动&quot;);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>可以看到，这份代码作者一开始先通过[[NSUserDefaults standardUserDefaults] boolForKey:@”firstStart”]（因为并没有进行赋值，所以默认为NO）取反来判断用户第一次启动app，然后在将其设为YES，下次进入的时候就会跑else块的代码了。</p>\n<p>相信都看出来了吧，逻辑没错，但是可读性缺并不好。都是这个BOOL的锅，默认为YES不就好了？</p>\n<h2 id=\"如何让BOOL更有可读性？\"><a href=\"#如何让BOOL更有可读性？\" class=\"headerlink\" title=\"如何让BOOL更有可读性？\"></a>如何让BOOL更有可读性？</h2><p>当时涌进脑海的第一个想法是用一个enum来存储两个值 isFirstLaunch，isDefaultLaunch，然后通过枚举转nsnumber来做启动判断，但是后来发现这样会写的很臃肿而且后面要用到这个判断的api调用时也会很麻烦，所以放弃了这个想法（是我想太多）。BOOL的简单有时真的不能被其他东西代替。<br>于是再想了一下，写了一个即简单又有可读性的code：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">_isFirstLaunch = ![[NSUserDefaults standardUserDefaults] objectForKey:@&quot;AppIsDefaultLaunch&quot;];</div><div class=\"line\"></div><div class=\"line\">if (_isFirstLaunch) &#123;</div><div class=\"line\">    [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@&quot;AppIsDefaultLaunch&quot;];</div><div class=\"line\">&#125;else &#123;</div><div class=\"line\">    NSLog(@&quot;default launch&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样看上去会让人更加容易理解，虽然不涉及什么算法和优化，但是可读性真的提升了不少（自我安慰）。</p>\n<p>看法到这里就讲的差不多了，纯粹分享和记录下来。如果有大牛看到并且有更好的想法跪求快快告知，求知的欲望是强烈的，前路是漫长的，加油！</p>\n","categories":["iOS"],"tags":["iOS","NSUserDefaults"]},{"title":"Runtime学习笔记2--Method Swizzling","url":"http://yoursite.com/2017/03/17/Runtime学习笔记2--Method Swizzling/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前文再续，书接上一回，我们知道了自己在开发的时候写的是“伪代码“执行的是另有其人后，就可以开始接触runtime的另一个黑魔法了，就是<strong>Method swizzling</strong>. 通俗点来讲，就是把自己写的一个方法在runtime执行阶段替换掉一个系统的方法，这符合了动态语言的特性，是runtime的用法的延伸。同时，我们可以利用苹果这一特性来实现AOP（面向切面编程）。</p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>Mattt Thompson 在 <a href=\"http://nshipster.com/method-swizzling/%20Method%20Swizzling\" target=\"_blank\" rel=\"external\">Method Swizzling</a> 一文中写道：</p>\n<blockquote>\n<p>Method swizzling is the process of changing the implementation of an existing selector. It’s a technique made possible by the fact that method invocations in Objective-C can be changed at runtime, by changing how selectors are mapped to underlying functions in a class’s dispatch table.</p>\n</blockquote>\n<p>因为Objective-C是运行时语言，也就是说究竟会调用何种方法要在运行期才能解析出来。那么我们其实也可以在运行时改变选择子名称。这样我们既不需要查看到源代码，又没有必要去重写子类来覆写方法就能改变类本身的功能。这样一来新功能就会在类的所有实例中表现出来，而不仅限于那些重写子类的实例。这种方案就叫做“方法调配”（method swizzling）。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>我们先来了解下 Objective-C 中方法 Method 的数据结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct method_t *Method;  </div><div class=\"line\">struct method_t &#123;  </div><div class=\"line\">    SEL name;</div><div class=\"line\">    const char *types;</div><div class=\"line\">    IMP imp;</div><div class=\"line\"></div><div class=\"line\">    struct SortBySELAddress :</div><div class=\"line\">        public std::binary_function&lt;const method_t&amp;,</div><div class=\"line\">                                    const method_t&amp;, bool&gt;</div><div class=\"line\">    &#123;</div><div class=\"line\">        bool operator() (const method_t&amp; lhs,</div><div class=\"line\">                         const method_t&amp; rhs)</div><div class=\"line\">        &#123; return lhs.name &lt; rhs.name; &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们可以看到，Method就是 struct methodt 类型的指针，所以我们重点看下结构体 methodt 的定义。在结构体 method_t 中定义了三个成员变量和一个成员函数：</p>\n<ul>\n<li>name 表示的是方法的名称，用于唯一标识某个方法，比如 @selector(viewWillAppear:) ； </li>\n<li>types 表示的是方法的返回值和参数类型（详细信息可以查阅苹果官方文档中的 Type Encodings）； </li>\n<li>imp是一个函数指针，指向方法的实现；</li>\n<li>SortBySELAddress 顾名思义，是一个根据 name 的地址对方法进行排序的函数。</li>\n</ul>\n<p>理论上，方法名称name与imp是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。</p>\n<p>二图以蔽之（也是盗图）：<br>正常的函数调用：<br><img src=\"http://img.blog.csdn.net/20161019232017680\" alt=\"正常的函数调用\"></p>\n<p>Method Swizzling：<br><img src=\"http://img.blog.csdn.net/20161019232141713\" alt=\"这里写图片描述\"></p>\n<p>看完估计就很清晰了。</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIViewController+Swizzling.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation UIViewController (Swizzling)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        Class class = [self class];</div><div class=\"line\">        </div><div class=\"line\">        SEL originalSelector = @selector(viewDidAppear:);</div><div class=\"line\">        SEL swizzledSelector = @selector(swizzledViewDidAppear:);</div><div class=\"line\">        </div><div class=\"line\">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class=\"line\">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class=\"line\">        </div><div class=\"line\">        BOOL didAddedMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class=\"line\">        </div><div class=\"line\">        NSLog(@&quot;%@&quot;,didAddedMethod?@&quot;YES&quot;:@&quot;NO&quot;);</div><div class=\"line\">        </div><div class=\"line\">        if (didAddedMethod) &#123;</div><div class=\"line\">            class_replaceMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</div><div class=\"line\">        &#125;else &#123;</div><div class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)swizzledViewDidAppear:(BOOL)animated &#123;</div><div class=\"line\">    [self swizzledViewDidAppear:animated];</div><div class=\"line\">    NSLog(@&quot;View Controller: %@ did appear animated: %@&quot;, NSStringFromClass([self class]), animated?@&quot;YES&quot;:@&quot;NO&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>从代码中我们可以看到，我们在runtime时调用了的class_replaceMethod() 将我们自己写swizzledViewDidAppear()替换了UIViewController的原生方法viewDidAppear()，我们可以利用这一特性，在不影响viewDidAppear()代码的情况下添加一些我们需要的function。<br>此处推荐一个关于Method Swizzling的第三方库<a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"external\">Aspects</a> ,这是一个封装好的AOP库。 使用Demo在此<a href=\"https://github.com/ouhuiju/MyIOSBrain/blob/DEV/MyIOSBrain/MyAspectsIntercepter.m\" target=\"_blank\" rel=\"external\">DEMO</a></p>\n<h2 id=\"Swift的Method-Swizzling\"><a href=\"#Swift的Method-Swizzling\" class=\"headerlink\" title=\"Swift的Method Swizzling\"></a>Swift的Method Swizzling</h2><p>我们在谈论Method Swizzling的时候都是建立在Objective-C的基础上的，但是随着Swift的普及，我们在使用Swift开发的时候有些时候也会用到这个特性。在什么场景下，Swift可以用Method Swizzling呢？这里有两个必要条件：</p>\n<ol>\n<li>包含 Swizzle 方法的类需要继承自 NSObject</li>\n<li>需要 Swizzle 的方法必须有动态属性（dynamic attribute）</li>\n</ol>\n<p>以上面例子为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\"></div><div class=\"line\">extension UIViewController &#123;</div><div class=\"line\">    override public static func initialize() &#123;</div><div class=\"line\">        </div><div class=\"line\">        struct Static &#123;</div><div class=\"line\">            static var token: dispatch_once_t = 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        dispatch_once(&amp;Static.token) &#123;</div><div class=\"line\">            let originalSelector = Selector(&quot;viewDidAppear:&quot;)</div><div class=\"line\">            let swizzledSelector = Selector(&quot;swizzledViewDidAppear:&quot;)</div><div class=\"line\">            </div><div class=\"line\">            let originalMethod = class_getInstanceMethod(self, originalSelector)</div><div class=\"line\">            let swizzledMethod = class_getInstanceMethod(self, swizzledSelector)</div><div class=\"line\">            </div><div class=\"line\">            let didAddMethod:Bool = class_addMethod(self, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))</div><div class=\"line\">            </div><div class=\"line\">            if didAddMethod &#123;</div><div class=\"line\">                class_replaceMethod(self, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod))</div><div class=\"line\">            &#125;else &#123;</div><div class=\"line\">                method_exchangeImplementations(originalMethod, swizzledMethod)</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    func swizzledViewDidAppear(animated: Bool) &#123;</div><div class=\"line\">        self.swizzledViewDidAppear(animated)</div><div class=\"line\">        </div><div class=\"line\">        print(&quot;View Controller: \\(self) did appear animated: \\(animated)&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Compare to the code we can see that:</p>\n<ol>\n<li>in Objective-C we need import <code>&lt;objc/runtime.h&gt;</code>, but in Swift no need.</li>\n<li>in Objective-C Swizzling is call in <code>- (void)load;</code> , in Swift it’s call in <code>func initialize()</code>.</li>\n</ol>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ol>\n<li>因为 Swizzling 会改变全局状态，所以我们需要在运行时采取一些预防措施。GCD 的dispatch_once 可以保证操作的原子性，确保代码只被执行一次，不管有多少个线程。</li>\n<li>有利也有弊，在 runtime 执行这类更改时，你就不能在编译时利用那些可用的安全检查了。因此，应该小心使用 Method Swizzling。</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://blog.ximu.site/runtime-methodswizzling/\" target=\"_blank\" rel=\"external\">Runtime系列2–Method Swizzling</a><br><a href=\"http://nshipster.com/method-swizzling/\" target=\"_blank\" rel=\"external\">Method Swizzling</a><br><a href=\"http://nshipster.cn/swift-objc-runtime/\" target=\"_blank\" rel=\"external\">Swift &amp; the Objective-C Runtime</a><br><a href=\"https://segmentfault.com/a/1190000004715337\" target=\"_blank\" rel=\"external\">How to use MethodSwizzling in Swift in high performance</a></p>\n","categories":["iOS"],"tags":["iOS","RunTime"]},{"title":"Runtime学习笔记1-－基础概念篇","url":"http://yoursite.com/2017/03/17/Runtime学习笔记1-－基础概念篇/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看了下ReactiveCocoa的源码发现RAC在给系统类添加rac_扩展的时候用到了很多Runtime层面的API，所以打算先从Runtime基础开始学起并纪录下来。由于网上关于Runtime的描述已经很详尽，所以就拾人牙慧，以作学习之用。</p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>Runtime是用C和汇编写的动态库，其将Objective-C跟C紧密结合起来，顾名思义，即“跑的时候“，其作用是：</p>\n<ol>\n<li>让我们可以在系统在运行时创建、检查或者修改类、对象和方法等。这区别于我们平时在iOS开发的正常模式（即创建好一堆UI和一堆逻辑然后不管死活的点CMD＋R），所以Runtime赋予了Objective-C很好的动态特性。</li>\n<li>通过传递消息找出最终的代码。</li>\n</ol>\n<p>在 <a href=\"http://blog.ximu.site/runtime-1/\" target=\"_blank\" rel=\"external\">Runtime 系列 1– 从一个崩溃谈起</a>  作者如是说：</p>\n<blockquote>\n<p>ObjC 是一种面向runtime(运行时)的语言，也就是说，它会尽可能地把代码执行的决策从编译和链接的时候，推迟到运行时。这给程序员写代码带来很大的灵活性，比如说你可以把消息转发给你想要的对象，或者随意交换一个方法的实现之类的。这就要求 runtime 能检测一个对象是否能对一个方法进行响应，然后再把这个方法分发到对应的对象去。我们拿 C 来跟 ObjC 对比一下。在 C 语言里面，一切从 main 函数开始，程序员写代码的时候是自上而下地，一个 C 的结构体或者说类吧，是不能把方法调用转发给其他对象的。但是在oc中，我们可以在运行时把上面的target换成其他对象，非常灵活。</p>\n</blockquote>\n<p>可见其实Runtime就是一个项目最后的决策者，Runtime贯穿整个项目的生命周期。</p>\n<h2 id=\"从-objc-msgSend谈起\"><a href=\"#从-objc-msgSend谈起\" class=\"headerlink\" title=\"从 objc_msgSend谈起\"></a>从 objc_msgSend谈起</h2><p>我们平时使用方法调用都是如此：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[target MethodName:var1];</div></pre></td></tr></table></figure>\n<p>其实在Runtime看来，这些都是伪代码。当项目开始编译时，这句代码会编译成如此：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_msgSend(target,@selector(MethodName:),var1);</div></pre></td></tr></table></figure>\n<p>objc_msgSend()是Runtime里面最基础也是最重要的函数。</p>\n<p>objc_msgSend函数的原型如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">id objc_msgSend ( id self, SEL op, ... );</div></pre></td></tr></table></figure></p>\n<p>上面的函数里面有两个参数id和SEL，我们分别看看。</p>\n<p><strong><em>id</em></strong></p>\n<p>一个指向类实例的指针：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_object *id;</div></pre></td></tr></table></figure>\n<p>那objc_object又是啥呢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_object &#123; Class isa; &#125;;</div></pre></td></tr></table></figure>\n<p>objc_object结构体包含一个isa指针，根据isa指针就可以找到对象所属的类。</p>\n<blockquote>\n<p>isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术。</p>\n</blockquote>\n<p><strong><em>SEL</em></strong><br>selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个SEL类型的方法选择器。</p>\n</blockquote>\n<p>可以根据SEL(方法编号)去类方法列表找到对应的实例方法的实现，或者去元类方法列表找到对应的类方法的实现.</p>\n<h2 id=\"isa\"><a href=\"#isa\" class=\"headerlink\" title=\"isa\"></a>isa</h2><p>所有的对象都是由其对应的类实例化而来。在Objective-C中，我们用到的几乎所有类都是NSObject类的子类。而NSObject的类定义格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface NSObject &lt;NSObject&gt; &#123;</div><div class=\"line\">Class isa;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个Class为何物？在objc.h中我们发现其仅仅是一个结构(struct)指针的typedef定义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>\n<p>同样的，objcclass又是什么呢？在Objective-C2.0中，objcclass的定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;  </div><div class=\"line\">Class isa;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们知道isa指针指向的是该对象所属的类，对于实例对象的isa指针我们知道是指向其所属的类，但是实例对象所属的类的isa指针又指向谁呢？这里我们先记住一点：类本身也是对象！！<br>那么既然类本身也是对象，那么他所属的类是谁？答案就是：元类！！<br>所以实例对象所属的类的isa指针指向的是元类。</p>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p> <strong>1. 类对象的实质</strong><br>类对象是由编译器创建的，即在编译时所谓的类，就是指类对象（官方文档中是这样说的： The class object is the compiled version of the class）。<br>任何直接或间接继承了NSObject的类，它的实例对象(instance objec)中都有一个isa指针，指向它的类对象(class object)。这个类对象(class object)中存储了关于这个实例对象(instace object)所属的类的定义的一切：包括变量，方法，遵守的协议等等。<br>因此，类对象能访问所有关于这个类的信息，利用这些信息可以产生一个新的实例，但是类对象不能访问任何实例对象的内容。当你调用一个 “类方法” 例如 [NSObject alloc],你事实上是发送了一个消息给他的类对象。</p>\n<p> <strong>2. 类对象和实例对象的区别</strong><br> 尽管类对象保留了一个类实例的原型，但它并不是实例本身。它没有自己的实例变量，也不能执行那些类的实例的方法（只有实例对象才可以执行实例方法）。然而，类的定义能包含那些特意为类对象准备的方法–类方法（ 而不是的实例方法）。类对象从父类那里继承类方法，就像实例从父类那里继承实例方法一样。</p>\n<p>类对象是一个功能完整的对象，所以也能被动态识别（dynamically typed），接收消息，从其他类继承方法。特殊之处在于它们是由编译器创建的，缺少它们自己的数据结构(实例变量），只是在运行时产生实例的代理。</p>\n<h2 id=\"元类\"><a href=\"#元类\" class=\"headerlink\" title=\"元类\"></a>元类</h2><p>实际上，类对象是元类对象的一个实例！！</p>\n<p>元类描述了 一个类对象，就像类对象描述了普通对象一样。不同的是元类的方法列表是类方法的集合，由类对象的选择器来响应。当向一个类发送消息时，objc_msgSend会通过类对象的isa指针定位到元类，并检查元类的方法列表（包括父类）来决定调用哪个方法。元类代替了类对象描述了类方法，就像类对象代替了实例对象描述了实例化方法。</p>\n<p>很显然，元类也是对象，也应该是其他类的实例，实际上元类是根元类(root class’s metaclass)的实例,而根元类是其自身的实例，即根元类的isa指针指向自身。</p>\n<p>类的superclass指向其父类，而元类的superclass则指向父类的元类。元类的super class链与类的super class链平行，所以类方法的继承与实例方法的继承也是并行的。而根元类(root class’s metaclass)的super_class指向根类(root class)，这样，整个指针链就链接起来了！！</p>\n<p>一图以蔽之（盗图）：<br><img src=\"http://7xslqw.com1.z0.glb.clouddn.com/2016/08/09---Snip20160809_2.png\" alt=\"这里写图片描述\"></p>\n<h2 id=\"消息转发步骤\"><a href=\"#消息转发步骤\" class=\"headerlink\" title=\"消息转发步骤\"></a>消息转发步骤</h2><p>消息转发步骤可以理解为objc_msgSend的实现原理。</p>\n<ol>\n<li>检测selector是否要被忽略。</li>\n<li>检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>\n<li>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。</li>\n<li>如果 cache 找不到就找一下方法分发表。</li>\n<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。</li>\n<li>如果还找不到就要开始进入动态方法解析。</li>\n</ol>\n<p>PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。</p>\n<p>一图以蔽之（盗图）：<br><img src=\"http://7xslqw.com1.z0.glb.clouddn.com/2016/08/09---Snip20160809_1.png\" alt=\"这里写图片描述\"></p>\n<h2 id=\"我的理解\"><a href=\"#我的理解\" class=\"headerlink\" title=\"我的理解\"></a>我的理解</h2><ol>\n<li>Runtime实际上作用跟Java中的反射相类似。</li>\n<li>综上所述，类对象(class object)中包含了类的实例变量，实例方法的定义，而元类对象(metaclass object)中包括了类的类方法(也就是C++中的静态方法)的定义。</li>\n<li>类对象存的是关于实例对象的信息(变量，实例方法等)，而元类对象(metaclass object)中存储的是关于类的信息(类的版本，名字，类方法等)。</li>\n<li>类对象(class object)和元类对象(metaclass object)的定义都是objc_class结构，其不同仅仅是在用途上，比如其中的方法列表在类对象(instance object)中保存的是实例方法(instance method)，而在元类对象(metaclass object)中则保存的是类方法(class method)</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://opensource.apple.com//source/objc4/objc4-208/runtime/objc-runtime.m%20objc%20runtime%20%E6%BA%90%E7%A0%81\" target=\"_blank\" rel=\"external\">objc-runtime源码</a><br><a href=\"http://blog.ximu.site/runtime-1/\" target=\"_blank\" rel=\"external\">Runtime 系列 1– 从一个崩溃谈起</a><br><a href=\"http://blog.csdn.net/jasonjwl/article/details/50998917\" target=\"_blank\" rel=\"external\">runtime基础篇</a></p>\n","categories":["iOS"],"tags":["iOS","RunTime"]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]